name: Electric Book Deploy Workflow FTP and SSH

on:
  workflow_call:
    inputs:
      config-file:
        description: 'Path to deploy configuration file'
        required: false
        default: '.github/workflows/deploy.config.json'
        type: string
      node-version:
        description: 'Node.js version to use'
        required: false
        default: '22'
        type: string
      ruby-version:
        description: 'Ruby version to use'
        required: false
        default: '3.2'
        type: string
      setup-command:
        description: 'Command to run for installing dependencies'
        required: false
        default: 'npm run setup'
        type: string
      build-command:
        description: 'Command to run for building the project'
        required: false
        default: 'npm run eb -- output'
        type: string

jobs:
  pre-check:
    runs-on: ubuntu-latest
    outputs:
      skip_book_server: ${{ steps.load_config.outputs.skip_book_server }}
      should_build: ${{ steps.check_builds.outputs.should_build }}
      should_deploy: ${{ steps.check_branch.outputs.should_deploy }}
      deploy_configs: ${{ steps.load_config.outputs.deploy_configs }}
      build_dirs: ${{ steps.load_config.outputs.build_dirs }}
      build_configs: ${{ steps.load_config.outputs.build_configs }}
      target_branch: ${{ steps.check_branch.outputs.target_branch }}
      media_repo: ${{ steps.load_config.outputs.media_repo }}
      media_dirs: ${{ steps.load_config.outputs.media_dirs }}

    steps:
    - name: Checkout config file
      uses: actions/checkout@v4
      with:
        sparse-checkout: ${{ inputs.config-file }}
        fetch-depth: 1

    - name: Load deployment configuration
      id: load_config
      run: |
        CONFIG_FILE="${{ inputs.config-file }}"
        if [ ! -f "$CONFIG_FILE" ]; then
          echo "‚ùå ERROR: $CONFIG_FILE file not found"
          exit 1
        fi
        
        FTP_SSH_EXISTS=$(jq -r 'has("ftp-ssh")' "$CONFIG_FILE")
        if [[ "${FTP_SSH_EXISTS}" != "true" ]]; then
          echo "üìö No ftp-ssh configuration found, skipping deployment."
          echo "skip_book_server=true" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        DEPLOY_CONFIGS=$(jq -r '.["ftp-ssh"].configs | join(",")' "$CONFIG_FILE")
        
        # Get builds count first to determine how to handle parsing
        BUILDS_COUNT=$(jq -r '.["ftp-ssh"].builds | length' "$CONFIG_FILE")
        
        if [[ $BUILDS_COUNT -eq 1 ]]; then
          # Single build - handle empty dir case specially
          BUILD_DIR=$(jq -r '.["ftp-ssh"].builds[0].dir' "$CONFIG_FILE")
          BUILD_CONFIG=$(jq -r '.["ftp-ssh"].builds[0].configs | if length > 0 then join(",") else "" end' "$CONFIG_FILE")
          BUILD_DIRS="${BUILD_DIR}"
          BUILD_CONFIGS="${BUILD_CONFIG}"
        else
          # Multiple builds - use array joining
          BUILD_DIRS=$(jq -r '.["ftp-ssh"].builds | map(.dir) | join(",")' "$CONFIG_FILE")
          BUILD_CONFIGS=$(jq -r '.["ftp-ssh"].builds | map(.configs | if length > 0 then join(",") else "" end) | join(";")' "$CONFIG_FILE")
        fi
        
        echo "deploy_configs=${DEPLOY_CONFIGS}" >> $GITHUB_OUTPUT
        echo "build_dirs=${BUILD_DIRS}" >> $GITHUB_OUTPUT
        echo "build_configs=${BUILD_CONFIGS}" >> $GITHUB_OUTPUT
        echo "skip_book_server=false" >> $GITHUB_OUTPUT
        
        # Check for media configuration
        MEDIA_REPO=$(jq -r '."ftp-ssh".media.repo // ""' "$CONFIG_FILE")
        MEDIA_DIRS=$(jq -r '."ftp-ssh".media.dirs // [] | join(",")' "$CONFIG_FILE")
        echo "media_repo=${MEDIA_REPO}" >> $GITHUB_OUTPUT
        echo "media_dirs=${MEDIA_DIRS}" >> $GITHUB_OUTPUT

    - name: Check for builds
      id: check_builds
      if: steps.load_config.outputs.skip_book_server == 'false'
      run: |
        BUILD_COUNT=$(jq -r '.["ftp-ssh"].builds | length' "${{ inputs.config-file }}")
        if [[ "${BUILD_COUNT}" -eq 0 ]]; then
          echo "üß± No builds configured, skipping deployment."
          echo "should_build=false" >> $GITHUB_OUTPUT
        else
          echo "should_build=true" >> $GITHUB_OUTPUT
        fi

    - name: Check if branch is allowed for deployment
      id: check_branch
      if: steps.check_builds.outputs.should_build == 'true'
      run: |
        CURRENT_BRANCH="${{ github.ref_name }}"
        if [ "$CURRENT_BRANCH" != "live" ] && [ "$CURRENT_BRANCH" != "staging" ]; then
          echo "‚ùå Branch '${CURRENT_BRANCH}' is not 'live' or 'staging', skipping deployment."
          echo "should_deploy=false" >> $GITHUB_OUTPUT
        else
          echo "‚úÖ Branch '${CURRENT_BRANCH}' is allowed for deployment."
          echo "should_deploy=true" >> $GITHUB_OUTPUT
          echo "target_branch=${CURRENT_BRANCH}" >> $GITHUB_OUTPUT
        fi

  deploy-to-web-server:
    needs: pre-check
    if: needs.pre-check.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout source repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ inputs.node-version }}
        cache: 'npm'

    - name: Setup Ruby
      uses: ruby/setup-ruby@v1
      with:
        ruby-version: ${{ inputs.ruby-version }}
        bundler-cache: true

    - name: Install dependencies
      run: ${{ inputs.setup-command }}

    - name: Build project

      run: |
        BUILD_DIRS_RAW="${{ needs.pre-check.outputs.build_dirs }}"
        BUILD_CONFIGS_RAW="${{ needs.pre-check.outputs.build_configs }}"
        echo "Debug: Raw build_dirs: '${BUILD_DIRS_RAW}'"
        echo "Debug: Raw build_configs: '${BUILD_CONFIGS_RAW}'"
        # Handle single build case (no commas or semicolons)
        if [[ "${BUILD_DIRS_RAW}" != *","* ]]; then
          DIRS=("${BUILD_DIRS_RAW}")
          CONFIGS_GROUPS=("${BUILD_CONFIGS_RAW}")
        else
          IFS=',' read -ra DIRS <<< "${BUILD_DIRS_RAW}"
          IFS=';' read -ra CONFIGS_GROUPS <<< "${BUILD_CONFIGS_RAW}"
        fi
        echo "Debug: DIRS array: [${DIRS[*]}]"
        echo "Debug: CONFIGS_GROUPS array: [${CONFIGS_GROUPS[*]}]"
        echo "Debug: DIRS length: ${#DIRS[@]}"
        echo "Debug: CONFIGS_GROUPS length: ${#CONFIGS_GROUPS[@]}"
        if [[ ${#DIRS[@]} -ne ${#CONFIGS_GROUPS[@]} ]]; then
          echo "‚ùå ERROR: Mismatch between build directories and configs."
          exit 1
        fi
        mkdir -p _build_staging
        # Get deployment configuration once
        CONFIG_FILE="${{ inputs.config-file }}"
        TARGET_BRANCH="${{ needs.pre-check.outputs.target_branch }}"
        DEPLOY_PATH=$(jq -r ".\"ftp-ssh\".${TARGET_BRANCH}.path" "$CONFIG_FILE")
        WEB_ROOT=$(jq -r ".\"ftp-ssh\".${TARGET_BRANCH}.\"web-root\"" "$CONFIG_FILE")
        for i in "${!DIRS[@]}"; do
          DIR_NAME="${DIRS[$i]}"
          CONFIG_GROUP="${CONFIGS_GROUPS[$i]// /}"
          # Calculate baseurl: deployment path + build dir
          if [[ -n "${DEPLOY_PATH}" && -n "${DIR_NAME}" ]]; then
            BASEURL="/${DEPLOY_PATH}/${DIR_NAME}"
          elif [[ -n "${DEPLOY_PATH}" ]]; then
            BASEURL="/${DEPLOY_PATH}"
          elif [[ -n "${DIR_NAME}" ]]; then
            BASEURL="/${DIR_NAME}"
          else
            BASEURL=""
          fi
          # Set Jekyll output source path
          if [[ -z "${BASEURL}" ]]; then
            SITE_SOURCE="_site"
          else
            SITE_SOURCE="_site${BASEURL}"
          fi
          # Set staging target path
          if [[ -n "${DIR_NAME}" ]]; then
            STAGING_TARGET="_build_staging/${DIR_NAME}"
          else
            STAGING_TARGET="_build_staging"
          fi
          if [[ -n "${{ needs.pre-check.outputs.deploy_configs }}" && -n "${CONFIG_GROUP}" ]]; then
            FULL_CONFIGS="${{ needs.pre-check.outputs.deploy_configs }},_configs/${CONFIG_GROUP}"
          elif [[ -n "${CONFIG_GROUP}" ]]; then
            FULL_CONFIGS="_configs/${CONFIG_GROUP}"
          else
            FULL_CONFIGS="${{ needs.pre-check.outputs.deploy_configs }}"
          fi
          ${{ inputs.build-command }} --baseurl="${BASEURL}" --configs="${FULL_CONFIGS}" --dontserve=true --deploy=true
          # Create target directory if needed
          if [[ "${STAGING_TARGET}" != "_build_staging" ]]; then
            mkdir -p "${STAGING_TARGET}"
          fi
          # Copy files to staging
          cp -r "${SITE_SOURCE}"/* "${STAGING_TARGET}/"
        done

    - name: Checkout and sync media repository
      if: needs.pre-check.outputs.media_repo != ''
      run: |
        MEDIA_REPO="${{ needs.pre-check.outputs.media_repo }}"
        TARGET_BRANCH="${{ needs.pre-check.outputs.target_branch }}"
        echo "üì¶ Checking out media repository: ${MEDIA_REPO} on branch ${TARGET_BRANCH}"
        echo "üîë Using token: ${{ secrets.ORG_DEPLOY_TOKEN != '' && '[REDACTED]' || '[EMPTY]' }}"

    - name: Checkout media repository
      id: checkout_media
      if: needs.pre-check.outputs.media_repo != ''
      continue-on-error: true
      uses: actions/checkout@v4
      with:
        repository: ${{ needs.pre-check.outputs.media_repo }}
        ref: ${{ needs.pre-check.outputs.target_branch }}
        token: ${{ secrets.ORG_DEPLOY_TOKEN }}
        path: _media_repo
        fetch-depth: 1

    - name: Fallback to default branch for media repo
      if: steps.checkout_media.outcome == 'failure' && needs.pre-check.outputs.media_repo != ''
      uses: actions/checkout@v4
      with:
        repository: ${{ needs.pre-check.outputs.media_repo }}
        token: ${{ secrets.ORG_DEPLOY_TOKEN }}
        path: _media_repo
        fetch-depth: 1

    - name: Sync media folders to staging area
      if: needs.pre-check.outputs.media_repo != '' && (steps.checkout_media.outcome == 'success' || steps.checkout_media.outcome == 'failure')
      run: |
        MEDIA_REPO="${{ needs.pre-check.outputs.media_repo }}"
        TARGET_BRANCH="${{ needs.pre-check.outputs.target_branch }}"
        MEDIA_DIRS_RAW="${{ needs.pre-check.outputs.media_dirs }}"
        
        echo "üîÑ Syncing media folders to staging area..."
        echo "Media dirs configured: ${MEDIA_DIRS_RAW}"
        
        # Handle media dirs configuration
        if [[ -n "${MEDIA_DIRS_RAW}" ]]; then
          # Parse comma-separated dirs
          IFS=',' read -ra MEDIA_DIRS <<< "${MEDIA_DIRS_RAW}"
          
          for media_dir in "${MEDIA_DIRS[@]}"; do
            # Remove leading/trailing whitespace
            media_dir=$(echo "$media_dir" | xargs)
            
            if [[ -d "_media_repo/$media_dir" ]]; then
              echo "  Syncing directory: $media_dir"
              
              # Create destination directory structure
              mkdir -p "_build_staging/$(dirname "$media_dir")"
              
              # Copy the directory contents
              cp -r "_media_repo/$media_dir" "_build_staging/$(dirname "$media_dir")/"
            else
              echo "  ‚ö†Ô∏è  Directory not found in media repo: $media_dir"
            fi
          done
        else
          echo "  üìù No media directories configured in 'dirs' array"
        fi
        
        # Clean up the temporary media repo
        rm -rf _media_repo
        echo "‚úÖ Media sync completed"

    - name: Load deployment configuration
      id: load_deploy_config
      run: |
        CONFIG_FILE="${{ inputs.config-file }}"
        TARGET_BRANCH="${{ needs.pre-check.outputs.target_branch }}"
        
        DEPLOY_TYPE=$(jq -r ".\"ftp-ssh\".${TARGET_BRANCH}.type" "$CONFIG_FILE")
        DEPLOY_PATH=$(jq -r ".\"ftp-ssh\".${TARGET_BRANCH}.path" "$CONFIG_FILE")
        WEB_ROOT=$(jq -r ".\"ftp-ssh\".${TARGET_BRANCH}.\"web-root\"" "$CONFIG_FILE")
        
        echo "deploy_type=${DEPLOY_TYPE}" >> $GITHUB_OUTPUT
        echo "deploy_path=${DEPLOY_PATH}" >> $GITHUB_OUTPUT
        echo "web_root=${WEB_ROOT}" >> $GITHUB_OUTPUT

    - name: Deploy via FTP
      if: steps.load_deploy_config.outputs.deploy_type == 'ftp'
      run: |
        # Install lftp for advanced FTP mirroring with delete support
        sudo apt-get update && sudo apt-get install -y lftp
        
        # Set variables from repository secrets and deployment config
        TARGET_BRANCH="${{ needs.pre-check.outputs.target_branch }}"
        if [ "$TARGET_BRANCH" = "live" ]; then
          FTP_SERVER="${{ secrets.DEPLOY_HOST_LIVE }}"
          FTP_PORT="${{ secrets.DEPLOY_PORT_LIVE }}"
          FTP_USER="${{ secrets.DEPLOY_USERNAME_LIVE }}"
          FTP_PASSWORD="${{ secrets.DEPLOY_FTP_PASSWORD }}"
        else
          FTP_SERVER="${{ secrets.DEPLOY_HOST_STAGING }}"
          FTP_PORT="${{ secrets.DEPLOY_PORT_STAGING }}"
          FTP_USER="${{ secrets.DEPLOY_USERNAME_STAGING }}"
          FTP_PASSWORD="${{ secrets.DEPLOY_FTP_PASSWORD }}"
        fi
        LOCAL_DIR="_build_staging/"
        
        # Calculate remote directory: web-root + path
        WEB_ROOT="${{ steps.load_deploy_config.outputs.web_root }}"
        DEPLOY_PATH="${{ steps.load_deploy_config.outputs.deploy_path }}"
        
        if [[ -n "${WEB_ROOT}" && -n "${DEPLOY_PATH}" ]]; then
          REMOTE_DIR="${WEB_ROOT}/${DEPLOY_PATH}"
        elif [[ -n "${WEB_ROOT}" ]]; then
          REMOTE_DIR="${WEB_ROOT}"
        elif [[ -n "${DEPLOY_PATH}" ]]; then
          REMOTE_DIR="${DEPLOY_PATH}"
        else
          REMOTE_DIR=""
        fi
        
        # Use lftp to mirror with delete (removes orphaned files after sync)
        lftp -c "
          set ssl:verify-certificate yes;
          set ftp:sync-mode false;
          open -u '$FTP_USER','$FTP_PASSWORD' -p '$FTP_PORT' '$FTP_SERVER';
          mirror -Rv --delete --exclude-glob '.git*' --exclude-glob 'node_modules' '$LOCAL_DIR' '$REMOTE_DIR';
          quit
        "

    - name: Deploy via SSH/SFTP
      if: steps.load_deploy_config.outputs.deploy_type == 'ssh'
      uses: burnett01/rsync-deployments@6.0.0
      env:
        WEB_ROOT: ${{ steps.load_deploy_config.outputs.web_root }}
        DEPLOY_PATH: ${{ steps.load_deploy_config.outputs.deploy_path }}
      with:
        switches: -avzr --delete
        path: _build_staging/
        remote_path: ${{ env.WEB_ROOT != 'null' && env.DEPLOY_PATH != 'null' && format('{0}/{1}', env.WEB_ROOT, env.DEPLOY_PATH) || env.WEB_ROOT != 'null' && env.WEB_ROOT || env.DEPLOY_PATH != 'null' && env.DEPLOY_PATH || '' }}
        remote_host: ${{ needs.pre-check.outputs.target_branch == 'live' && secrets.DEPLOY_HOST_LIVE || secrets.DEPLOY_HOST_STAGING }}
        remote_port: ${{ needs.pre-check.outputs.target_branch == 'live' && secrets.DEPLOY_PORT_LIVE || secrets.DEPLOY_PORT_STAGING }}
        remote_user: ${{ needs.pre-check.outputs.target_branch == 'live' && secrets.DEPLOY_USERNAME_LIVE || secrets.DEPLOY_USERNAME_STAGING }}
        remote_key: ${{ secrets.DEPLOY_SSH_PRIVATE_KEY }}

    - name: Deployment Summary
      run: |
        TARGET_BRANCH="${{ needs.pre-check.outputs.target_branch }}"
        if [ "$TARGET_BRANCH" = "live" ]; then
          DEPLOY_HOST="${{ secrets.DEPLOY_HOST_LIVE }}"
          DEPLOY_USER="${{ secrets.DEPLOY_USERNAME_LIVE }}"
        else
          DEPLOY_HOST="${{ secrets.DEPLOY_HOST_STAGING }}"
          DEPLOY_USER="${{ secrets.DEPLOY_USERNAME_STAGING }}"
        fi
        
        echo "‚úÖ Successfully deployed via ${{ steps.load_deploy_config.outputs.deploy_type }}"
        echo "üåê Host: ${DEPLOY_HOST}"
        echo "üë§ User: ${DEPLOY_USER}"
        echo "üìÅ Source branch: ${{ github.ref_name }}"
        echo "üìÇ Deployed directories: ${{ needs.pre-check.outputs.build_dirs }}"
        echo "üîß Build configs used: ${{ needs.pre-check.outputs.build_configs }}"
        echo "üîó Called from: ${{ github.repository }}"

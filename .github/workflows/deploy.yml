name: Electric Book Deploy Workflow FTP and SSH

on:
  workflow_call:
    inputs:
      config-file:
        description: 'Path to deploy configuration file'
        required: false
        default: '.github/workflows/deploy.config.json'
        type: string
      node-version:
        description: 'Node.js version to use'
        required: false
        default: '22'
        type: string
      ruby-version:
        description: 'Ruby version to use'
        required: false
        default: '3.2'
        type: string
      setup-command:
        description: 'Command to run for installing dependencies'
        required: false
        default: 'npm run setup'
        type: string
      build-command:
        description: 'Command to run for building the project'
        required: false
        default: 'npm run eb -- output --baseurl="${BASEURL}" --configs="${FULL_CONFIGS}" --dontserve=true --deploy=true'
        type: string

jobs:
  pre-check:
    runs-on: ubuntu-latest
    outputs:
      skip_book_server: ${{ steps.check_config.outputs.skip_book_server }}
      deploy_configs: ${{ steps.check_config.outputs.deploy_configs }}
      # We output the whole builds JSON object to avoid string splitting issues later
      builds_json: ${{ steps.check_config.outputs.builds_json }}
      media_repo: ${{ steps.check_config.outputs.media_repo }}
      media_dirs: ${{ steps.check_config.outputs.media_dirs }}
      should_deploy: ${{ steps.check_branch.outputs.should_deploy }}
      target_branch: ${{ steps.check_branch.outputs.target_branch }}

    steps:
      - name: Checkout config file
        uses: actions/checkout@v4
        with:
          sparse-checkout: ${{ inputs.config-file }}
          fetch-depth: 1

      - name: Load deployment configuration
        id: check_config
        run: |
          CONFIG_FILE="${{ inputs.config-file }}"
          if [ ! -f "$CONFIG_FILE" ]; then
            echo "‚ùå ERROR: $CONFIG_FILE file not found"
            exit 1
          fi

          # Check if ftp-ssh key exists
          if [[ $(jq -r 'has("ftp-ssh")' "$CONFIG_FILE") != "true" ]]; then
            echo "üìö No ftp-ssh configuration found, skipping."
            echo "skip_book_server=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Check if builds array is empty
          BUILDS_COUNT=$(jq -r '.["ftp-ssh"].builds | length' "$CONFIG_FILE")
          if [[ "$BUILDS_COUNT" -eq 0 ]]; then
             echo "üß± No builds configured, skipping."
             echo "skip_book_server=true" >> $GITHUB_OUTPUT
             exit 0
          fi

          echo "skip_book_server=false" >> $GITHUB_OUTPUT

          # Extract configs
          DEPLOY_CONFIGS=$(jq -r '.["ftp-ssh"].configs | join(",")' "$CONFIG_FILE")
          echo "deploy_configs=${DEPLOY_CONFIGS}" >> $GITHUB_OUTPUT

          # Extract builds as a compressed JSON string to pass cleanly to next job
          BUILDS_JSON=$(jq -c '.["ftp-ssh"].builds' "$CONFIG_FILE")
          echo "builds_json=${BUILDS_JSON}" >> $GITHUB_OUTPUT
          
          # Extract media config
          echo "media_repo=$(jq -r '."ftp-ssh".media.repo // ""' "$CONFIG_FILE")" >> $GITHUB_OUTPUT
          echo "media_dirs=$(jq -r '."ftp-ssh".media.dirs // [] | join(",")' "$CONFIG_FILE")" >> $GITHUB_OUTPUT

      - name: Check branch
        id: check_branch
        if: steps.check_config.outputs.skip_book_server == 'false'
        run: |
          CURRENT="${{ github.ref_name }}"
          if [[ "$CURRENT" == "live" || "$CURRENT" == "staging" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "target_branch=$CURRENT" >> $GITHUB_OUTPUT
          else
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo "‚ùå Branch '$CURRENT' is not allowed. Skipping."
          fi

  deploy-to-web-server:
    needs: pre-check
    if: needs.pre-check.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    # Map secrets to env vars here to avoid repetitive if/else logic in steps
    env:
      TARGET_BRANCH: ${{ needs.pre-check.outputs.target_branch }}
      DEPLOY_HOST: ${{ needs.pre-check.outputs.target_branch == 'live' && secrets.DEPLOY_HOST_LIVE || secrets.DEPLOY_HOST_STAGING }}
      DEPLOY_PORT: ${{ needs.pre-check.outputs.target_branch == 'live' && secrets.DEPLOY_PORT_LIVE || secrets.DEPLOY_PORT_STAGING }}
      DEPLOY_USER: ${{ needs.pre-check.outputs.target_branch == 'live' && secrets.DEPLOY_USERNAME_LIVE || secrets.DEPLOY_USERNAME_STAGING }}
      DEPLOY_PASS: ${{ secrets.DEPLOY_FTP_PASSWORD }}
    
    steps:
      - name: Checkout source
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for Node.js dependencies
        id: check_node
        run: |
          if [ -f "package-lock.json" ]; then
            echo "has_package_lock=true" >> $GITHUB_OUTPUT
            echo "üì¶ Found package-lock.json, will setup Node.js"
          else
            echo "has_package_lock=false" >> $GITHUB_OUTPUT
            echo "üìã No package-lock.json found, skipping Node.js setup"
          fi

      - name: Setup Node.js
        if: steps.check_node.outputs.has_package_lock == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node-version }}
          cache: 'npm'

      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: ${{ inputs.ruby-version }}
          bundler-cache: true

      - name: Install dependencies
        if: steps.check_node.outputs.has_package_lock == 'true'
        run: ${{ inputs.setup-command }}

      - name: Setup media repository
        if: needs.pre-check.outputs.media_repo != ''
        id: setup_media
        run: |
          MEDIA_REPO="${{ needs.pre-check.outputs.media_repo }}"
          TARGET_BRANCH="${{ env.TARGET_BRANCH }}"
          
          echo "üîç Checking media repository: $MEDIA_REPO"
          echo "üåø Target branch: $TARGET_BRANCH"
          
          # Check if the target branch exists in the media repository
          if git ls-remote --heads https://${{ secrets.ORG_DEPLOY_TOKEN }}@github.com/$MEDIA_REPO.git $TARGET_BRANCH | grep -q $TARGET_BRANCH; then
            echo "‚úÖ Branch '$TARGET_BRANCH' exists in media repository"
            echo "checkout_ref=$TARGET_BRANCH" >> $GITHUB_OUTPUT
            echo "checkout_success=true" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è Branch '$TARGET_BRANCH' not found in media repository"
            echo "üìã Will use default branch instead"
            echo "checkout_ref=" >> $GITHUB_OUTPUT
            echo "checkout_success=false" >> $GITHUB_OUTPUT
          fi

      - name: Checkout media repository
        if: needs.pre-check.outputs.media_repo != '' && steps.setup_media.outputs.checkout_success == 'true'
        uses: actions/checkout@v4
        with:
          repository: ${{ needs.pre-check.outputs.media_repo }}
          ref: ${{ steps.setup_media.outputs.checkout_ref }}
          token: ${{ secrets.ORG_DEPLOY_TOKEN }}
          path: _media_repo
          fetch-depth: 1

      - name: Checkout media repository (default branch)
        if: needs.pre-check.outputs.media_repo != '' && steps.setup_media.outputs.checkout_success == 'false'
        uses: actions/checkout@v4
        with:
          repository: ${{ needs.pre-check.outputs.media_repo }}
          token: ${{ secrets.ORG_DEPLOY_TOKEN }}
          path: _media_repo
          fetch-depth: 1

      - name: Build and Prepare Staging
        id: build_project
        run: |
          mkdir -p _build_staging
          
          CONFIG_FILE="${{ inputs.config-file }}"
          BUILDS_JSON='${{ needs.pre-check.outputs.builds_json }}'
          DEPLOY_CONFIGS="${{ needs.pre-check.outputs.deploy_configs }}"
          
          # Get path settings
          DEPLOY_PATH=$(jq -r ".\"ftp-ssh\".\"$TARGET_BRANCH\".path" "$CONFIG_FILE")
          WEB_ROOT=$(jq -r ".\"ftp-ssh\".\"$TARGET_BRANCH\".\"web-root\"" "$CONFIG_FILE")
          DEPLOY_TYPE=$(jq -r ".\"ftp-ssh\".\"$TARGET_BRANCH\".type" "$CONFIG_FILE")
          
          echo "deploy_type=$DEPLOY_TYPE" >> $GITHUB_OUTPUT
          
          # Calculate Remote Path
          REMOTE_DIR="${WEB_ROOT%/}/${DEPLOY_PATH#/}"
          if [[ -z "$WEB_ROOT" ]]; then REMOTE_DIR="$DEPLOY_PATH"; fi
          if [[ -z "$DEPLOY_PATH" ]]; then REMOTE_DIR="$WEB_ROOT"; fi
          echo "remote_dir=$REMOTE_DIR" >> $GITHUB_OUTPUT

          # --- Loop through builds ---
          echo "$BUILDS_JSON" | jq -c '.[]' | while read -r build_item; do
            DIR_NAME=$(echo "$build_item" | jq -r '.dir')
            BUILD_CONFIG=$(echo "$build_item" | jq -r '.configs | join(",")')
            
            echo "---------------------------------------------------"
            echo "üî® Processing build: $DIR_NAME"
            
            # 1. Calculate BaseURL
            if [[ -n "${DEPLOY_PATH}" && -n "${DIR_NAME}" ]]; then
              BASEURL="/${DEPLOY_PATH}/${DIR_NAME}"
            elif [[ -n "${DEPLOY_PATH}" ]]; then
              BASEURL="/${DEPLOY_PATH}"
            elif [[ -n "${DIR_NAME}" ]]; then
              BASEURL="/${DIR_NAME}"
            else
              BASEURL=""
            fi
            
            # 2. Determine Configs
            if [[ -n "${DEPLOY_CONFIGS}" && -n "${BUILD_CONFIG}" ]]; then
              FULL_CONFIGS="${DEPLOY_CONFIGS},_configs/${BUILD_CONFIG}"
            elif [[ -n "${BUILD_CONFIG}" ]]; then
              FULL_CONFIGS="_configs/${BUILD_CONFIG}"
            else
              FULL_CONFIGS="${DEPLOY_CONFIGS}"
            fi

            # 3. Build Project
            echo "   Running build command..."
            ${{ inputs.build-command }}
            
            # 4. Define Targets
            SITE_SOURCE="_site${BASEURL}"
            STAGING_TARGET="_build_staging${BASEURL}"

            # 5. Move Site to Staging FIRST
            # This puts index.html at _build_staging/baseurl/index.html
            echo "   üì¶ Moving site to staging: $STAGING_TARGET"
            mkdir -p "$STAGING_TARGET"
            
            if [[ -d "$SITE_SOURCE" ]]; then
              # Copy all files including hidden files like .htaccess
              cp -r "$SITE_SOURCE"/. "$STAGING_TARGET/"
              rm -rf "$SITE_SOURCE"
            else 
              echo "   ‚ùå Error: Build output directory $SITE_SOURCE not found!"
              exit 1
            fi

            # 6. Sync Media DIRECTLY to Staging (Correct Path)
            MEDIA_DIRS_RAW="${{ needs.pre-check.outputs.media_dirs }}"
            if [[ -d "_media_repo" && -n "$MEDIA_DIRS_RAW" ]]; then
              echo "   üîÑ Syncing media..."
              IFS=',' read -ra MEDIA_DIRS <<< "$MEDIA_DIRS_RAW"
              for media_dir in "${MEDIA_DIRS[@]}"; do
                media_dir=$(echo "$media_dir" | xargs)
                if [[ -d "_media_repo/$media_dir" ]]; then
                  
                  DEST_DIR="${STAGING_TARGET}/$(dirname "$media_dir")"
                  
                  mkdir -p "$DEST_DIR"
                  cp -r "_media_repo/$media_dir" "$DEST_DIR/"
                  echo "      Synced: $media_dir -> $DEST_DIR"
                fi
              done
            fi

          done

          rm -rf _media_repo
      
      - name: Deploy via FTP
        if: steps.build_project.outputs.deploy_type == 'ftp'
        run: |
          sudo apt-get update && sudo apt-get install -y lftp
          
          LOCAL_DIR="_build_staging/"
          REMOTE_DIR="${{ steps.build_project.outputs.remote_dir }}"
          CONFIG_FILE="${{ inputs.config-file }}"
          BUILDS_JSON='${{ needs.pre-check.outputs.builds_json }}'
          
          echo "üöÄ Deploying via FTP to: $REMOTE_DIR"

          # Check if any builds have specific directories
          HAS_DIRS=$(echo "$BUILDS_JSON" | jq -r 'map(select(.dir != "")) | length > 0')
          
          if [[ "$HAS_DIRS" == "true" ]]; then
            echo "üìÅ Deploying per-directory to avoid root-level deletions"
            
            # Deploy each build directory individually
            echo "$BUILDS_JSON" | jq -c '.[]' | while read -r build_item; do
              DIR_NAME=$(echo "$build_item" | jq -r '.dir')
              
              if [[ -n "$DIR_NAME" && -d "${LOCAL_DIR}${DIR_NAME}" ]]; then
                echo "   Syncing directory: $DIR_NAME"
                
                lftp -c "
                  set ssl:verify-certificate yes;
                  set ftp:sync-mode false;
                  open -u '$DEPLOY_USER','$DEPLOY_PASS' -p '$DEPLOY_PORT' '$DEPLOY_HOST';
                  mirror -Rv --delete --exclude-glob '.git*' --exclude-glob 'node_modules' '${LOCAL_DIR}${DIR_NAME}/' '${REMOTE_DIR}/${DIR_NAME}';
                  quit
                "
              fi
            done
            
            # Also sync any root-level files (without --delete to preserve other directories)
            if [[ -n "$(find "$LOCAL_DIR" -maxdepth 1 -type f)" ]]; then
              echo "   Syncing root-level files"
              lftp -c "
                set ssl:verify-certificate yes;
                set ftp:sync-mode false;
                open -u '$DEPLOY_USER','$DEPLOY_PASS' -p '$DEPLOY_PORT' '$DEPLOY_HOST';
                mirror -Rv --exclude-glob '.git*' --exclude-glob 'node_modules' --include-glob='*.*' --exclude-glob='*/' '$LOCAL_DIR' '$REMOTE_DIR';
                quit
              "
            fi
          else
            echo "üì¶ Deploying entire directory (no specific build dirs)"
            lftp -c "
              set ssl:verify-certificate yes;
              set ftp:sync-mode false;
              open -u '$DEPLOY_USER','$DEPLOY_PASS' -p '$DEPLOY_PORT' '$DEPLOY_HOST';
              mirror -Rv --delete --exclude-glob '.git*' --exclude-glob 'node_modules' '$LOCAL_DIR' '$REMOTE_DIR';
              quit
            "
          fi

      - name: Deploy via SSH/SFTP
        if: steps.build_project.outputs.deploy_type == 'ssh'
        run: |
          # Setup SSH key
          mkdir -p ~/.ssh
          echo "${{ secrets.DEPLOY_SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          LOCAL_DIR="_build_staging/"
          REMOTE_DIR="${{ steps.build_project.outputs.remote_dir }}"
          CONFIG_FILE="${{ inputs.config-file }}"
          BUILDS_JSON='${{ needs.pre-check.outputs.builds_json }}'
          
          echo "üöÄ Deploying via SSH to: $REMOTE_DIR"
          
          # Check if any builds have specific directories
          HAS_DIRS=$(echo "$BUILDS_JSON" | jq -r 'map(select(.dir != "")) | length > 0')
          
          if [[ "$HAS_DIRS" == "true" ]]; then
            echo "üìÅ Deploying per-directory to avoid root-level deletions"
            
            # Deploy each build directory individually
            echo "$BUILDS_JSON" | jq -c '.[]' | while read -r build_item; do
              DIR_NAME=$(echo "$build_item" | jq -r '.dir')
              
              if [[ -n "$DIR_NAME" && -d "${LOCAL_DIR}${DIR_NAME}" ]]; then
                echo "   Syncing directory: $DIR_NAME"
                rsync -avzr --delete \
                  -e "ssh -i ~/.ssh/deploy_key -p ${{ env.DEPLOY_PORT }} -o StrictHostKeyChecking=no" \
                  "${LOCAL_DIR}${DIR_NAME}/" \
                  "${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }}:${REMOTE_DIR}/${DIR_NAME}/"
              fi
            done
            
            # Also sync any root-level files (without --delete to preserve other directories)
            if [[ -n "$(find "$LOCAL_DIR" -maxdepth 1 -type f)" ]]; then
              echo "   Syncing root-level files"
              rsync -avzr \
                -e "ssh -i ~/.ssh/deploy_key -p ${{ env.DEPLOY_PORT }} -o StrictHostKeyChecking=no" \
                --include='*.*' --exclude='*/' \
                "${LOCAL_DIR}" \
                "${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }}:${REMOTE_DIR}/"
            fi
          else
            echo "üì¶ Deploying entire directory (no specific build dirs)"
            rsync -avzr --delete \
              -e "ssh -i ~/.ssh/deploy_key -p ${{ env.DEPLOY_PORT }} -o StrictHostKeyChecking=no" \
              "${LOCAL_DIR}" \
              "${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }}:${REMOTE_DIR}/"
          fi
          
          # Clean up SSH key
          rm -f ~/.ssh/deploy_key

      - name: Deployment Summary
        run: |
          echo "‚úÖ Deployed successfully via ${{ steps.build_project.outputs.deploy_type }}"
          echo "üåê Host: ${{ env.DEPLOY_HOST }}"
          echo "üìÇ Remote Path: ${{ steps.build_project.outputs.remote_dir }}"
          echo "üåø Branch: $TARGET_BRANCH"
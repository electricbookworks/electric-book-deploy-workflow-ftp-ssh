name: Electric Book Deploy Workflow FTP and SSH

on:
  workflow_call:
    inputs:
      config-file:
        description: 'Path to deploy configuration file'
        required: false
        default: '.github/workflows/deploy.config.json'
        type: string
      node-version:
        description: 'Node.js version to use'
        required: false
        default: '22'
        type: string
      ruby-version:
        description: 'Ruby version to use'
        required: false
        default: '3.2'
        type: string

jobs:
  pre-check:
    runs-on: Linux-4core-16gb-ram-150gb-sso
    outputs:
      skip_book_server: ${{ steps.load_config.outputs.skip_book_server }}
      should_build: ${{ steps.check_builds.outputs.should_build }}
      should_deploy: ${{ steps.check_branch.outputs.should_deploy }}
      deploy_configs: ${{ steps.load_config.outputs.deploy_configs }}
      build_dirs: ${{ steps.load_config.outputs.build_dirs }}
      build_configs: ${{ steps.load_config.outputs.build_configs }}
      target_branch: ${{ steps.check_branch.outputs.target_branch }}
      media_repo: ${{ steps.load_config.outputs.media_repo }}

    steps:
    - name: Checkout config file
      uses: actions/checkout@v4
      with:
        sparse-checkout: ${{ inputs.config-file }}
        fetch-depth: 1

    - name: Load deployment configuration
      id: load_config
      run: |
        CONFIG_FILE="${{ inputs.config-file }}"
        if [ ! -f "$CONFIG_FILE" ]; then
          echo "‚ùå ERROR: $CONFIG_FILE file not found"
          exit 1
        fi
        
        FTP_SSH_EXISTS=$(jq -r 'has("ftp-ssh")' "$CONFIG_FILE")
        if [[ "${FTP_SSH_EXISTS}" != "true" ]]; then
          echo "üìö No ftp-ssh configuration found, skipping deployment."
          echo "skip_book_server=true" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        DEPLOY_CONFIGS=$(jq -r '.["ftp-ssh"].configs | join(",")' "$CONFIG_FILE")
        
        # Get builds count first to determine how to handle parsing
        BUILDS_COUNT=$(jq -r '.["ftp-ssh"].builds | length' "$CONFIG_FILE")
        
        if [[ $BUILDS_COUNT -eq 1 ]]; then
          # Single build - handle empty dir case specially
          BUILD_DIR=$(jq -r '.["ftp-ssh"].builds[0].dir' "$CONFIG_FILE")
          BUILD_CONFIG=$(jq -r '.["ftp-ssh"].builds[0].configs | if length > 0 then join(",") else "" end' "$CONFIG_FILE")
          BUILD_DIRS="${BUILD_DIR}"
          BUILD_CONFIGS="${BUILD_CONFIG}"
        else
          # Multiple builds - use array joining
          BUILD_DIRS=$(jq -r '.["ftp-ssh"].builds | map(.dir) | join(",")' "$CONFIG_FILE")
          BUILD_CONFIGS=$(jq -r '.["ftp-ssh"].builds | map(.configs | if length > 0 then join(",") else "" end) | join(";")' "$CONFIG_FILE")
        fi
        
        echo "deploy_configs=${DEPLOY_CONFIGS}" >> $GITHUB_OUTPUT
        echo "build_dirs=${BUILD_DIRS}" >> $GITHUB_OUTPUT
        echo "build_configs=${BUILD_CONFIGS}" >> $GITHUB_OUTPUT
        echo "skip_book_server=false" >> $GITHUB_OUTPUT
        
        # Check for media configuration
        MEDIA_REPO=$(jq -r '."ftp-ssh".media.repo // ""' "$CONFIG_FILE")
        echo "media_repo=${MEDIA_REPO}" >> $GITHUB_OUTPUT

    - name: Check for builds
      id: check_builds
      if: steps.load_config.outputs.skip_book_server == 'false'
      run: |
        BUILD_COUNT=$(jq -r '.["ftp-ssh"].builds | length' "${{ inputs.config-file }}")
        if [[ "${BUILD_COUNT}" -eq 0 ]]; then
          echo "üß± No builds configured, skipping deployment."
          echo "should_build=false" >> $GITHUB_OUTPUT
        else
          echo "should_build=true" >> $GITHUB_OUTPUT
        fi

    - name: Check if branch is allowed for deployment
      id: check_branch
      if: steps.check_builds.outputs.should_build == 'true'
      run: |
        CURRENT_BRANCH="${{ github.ref_name }}"
        if [ "$CURRENT_BRANCH" != "live" ] && [ "$CURRENT_BRANCH" != "staging" ]; then
          echo "‚ùå Branch '${CURRENT_BRANCH}' is not 'live' or 'staging', skipping deployment."
          echo "should_deploy=false" >> $GITHUB_OUTPUT
        else
          echo "‚úÖ Branch '${CURRENT_BRANCH}' is allowed for deployment."
          echo "should_deploy=true" >> $GITHUB_OUTPUT
          echo "target_branch=${CURRENT_BRANCH}" >> $GITHUB_OUTPUT
        fi

  deploy-to-web-server:
    needs: pre-check
    if: needs.pre-check.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout source repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ inputs.node-version }}
        cache: 'npm'

    - name: Setup Ruby
      uses: ruby/setup-ruby@v1
      with:
        ruby-version: ${{ inputs.ruby-version }}
        bundler-cache: true

    - name: Install dependencies
      run: npm run setup

    - name: Build project
      run: |
        BUILD_DIRS_RAW="${{ needs.pre-check.outputs.build_dirs }}"
        BUILD_CONFIGS_RAW="${{ needs.pre-check.outputs.build_configs }}"
        
        echo "Debug: Raw build_dirs: '${BUILD_DIRS_RAW}'"
        echo "Debug: Raw build_configs: '${BUILD_CONFIGS_RAW}'"
        
        # Handle single build case (no commas or semicolons)
        if [[ "${BUILD_DIRS_RAW}" != *","* ]]; then
          DIRS=("${BUILD_DIRS_RAW}")
          CONFIGS_GROUPS=("${BUILD_CONFIGS_RAW}")
        else
          IFS=',' read -ra DIRS <<< "${BUILD_DIRS_RAW}"
          IFS=';' read -ra CONFIGS_GROUPS <<< "${BUILD_CONFIGS_RAW}"
        fi
        
        echo "Debug: DIRS array: [${DIRS[*]}]"
        echo "Debug: CONFIGS_GROUPS array: [${CONFIGS_GROUPS[*]}]"
        echo "Debug: DIRS length: ${#DIRS[@]}"
        echo "Debug: CONFIGS_GROUPS length: ${#CONFIGS_GROUPS[@]}"
        
        if [[ ${#DIRS[@]} -ne ${#CONFIGS_GROUPS[@]} ]]; then
          echo "‚ùå ERROR: Mismatch between build directories and configs."
          exit 1
        fi
        
        mkdir -p _build_staging
        
        for i in "${!DIRS[@]}"; do
          DIR_NAME="${DIRS[$i]}"
          CONFIG_GROUP="${CONFIGS_GROUPS[$i]// /}"
          
          # Treat empty dir as root
          if [[ -z "${DIR_NAME}" ]]; then
            BASEURL=""
            SITE_SOURCE="_site"
            STAGING_TARGET="_build_staging"
          else
            BASEURL="/${DIR_NAME}"
            SITE_SOURCE="_site/${DIR_NAME}"
            STAGING_TARGET="_build_staging/${DIR_NAME}"
          fi
          
          if [[ -n "${{ needs.pre-check.outputs.deploy_configs }}" && -n "${CONFIG_GROUP}" ]]; then
            FULL_CONFIGS="${{ needs.pre-check.outputs.deploy_configs }},_configs/${CONFIG_GROUP}"
          elif [[ -n "${CONFIG_GROUP}" ]]; then
            FULL_CONFIGS="_configs/${CONFIG_GROUP}"
          else
            FULL_CONFIGS="${{ needs.pre-check.outputs.deploy_configs }}"
          fi
          
          npm run eb -- output --baseurl="${BASEURL}" --configs="${FULL_CONFIGS}" --dontserve=true --deploy=true
          
          if [[ -n "${DIR_NAME}" ]]; then
            mkdir -p "${STAGING_TARGET}"
          fi
          cp -r "${SITE_SOURCE}"/* "${STAGING_TARGET}/"
        done

    - name: Checkout and sync media repository
      if: needs.pre-check.outputs.media_repo != ''
      run: |
        MEDIA_REPO="${{ needs.pre-check.outputs.media_repo }}"
        TARGET_BRANCH="${{ needs.pre-check.outputs.target_branch }}"
        
        echo "üì¶ Checking out media repository: ${MEDIA_REPO} on branch ${TARGET_BRANCH}"
        echo "üîë Using token: ${{ secrets.ORG_DEPLOY_TOKEN != '' && '[REDACTED]' || '[EMPTY]' }}"

    - name: Checkout media repository
      if: needs.pre-check.outputs.media_repo != ''
      uses: actions/checkout@v4
      with:
        repository: ${{ needs.pre-check.outputs.media_repo }}
        ref: ${{ needs.pre-check.outputs.target_branch }}
        token: ${{ secrets.ORG_DEPLOY_TOKEN }}
        path: _media_repo
        fetch-depth: 1

    - name: Fallback to default branch for media repo
      if: failure() && needs.pre-check.outputs.media_repo != ''
      uses: actions/checkout@v4
      with:
        repository: ${{ needs.pre-check.outputs.media_repo }}
        token: ${{ secrets.ORG_DEPLOY_TOKEN }}
        path: _media_repo
        fetch-depth: 1

    - name: Sync media folders to staging area
      if: needs.pre-check.outputs.media_repo != ''
      run: |
        MEDIA_REPO="${{ needs.pre-check.outputs.media_repo }}"
        TARGET_BRANCH="${{ needs.pre-check.outputs.target_branch }}"
        
        # Sync only root-level folders (not files) to the staging area
        # Exclude folders starting with '_' or '.'
        echo "üîÑ Syncing media folders to staging area..."
        
        for item in _media_repo/*/; do
          if [ -d "$item" ]; then
            folder_name=$(basename "$item")
            # Skip folders starting with '_' or '.'
            if [[ ! "$folder_name" =~ ^[_\.].*$ ]]; then
              echo "  Syncing folder: $folder_name"
              # Create destination folder if it doesn't exist
              mkdir -p "_build_staging/$folder_name"
              # Copy recursively without deleting existing files
              cp -r "$item"* "_build_staging/$folder_name/"
            else
              echo "  Skipping folder: $folder_name (starts with '_' or '.')"
            fi
          fi
        done
        
        # Clean up the temporary media repo
        rm -rf _media_repo
        
        echo "‚úÖ Media sync completed"

    - name: Load deployment configuration
      id: load_deploy_config
      run: |
        CONFIG_FILE="${{ inputs.config-file }}"
        TARGET_BRANCH="${{ needs.pre-check.outputs.target_branch }}"
        
        DEPLOY_TYPE=$(jq -r ".\"ftp-ssh\".${TARGET_BRANCH}.type" "$CONFIG_FILE")
        DEPLOY_PATH=$(jq -r ".\"ftp-ssh\".${TARGET_BRANCH}.path" "$CONFIG_FILE")
        
        echo "deploy_type=${DEPLOY_TYPE}" >> $GITHUB_OUTPUT
        echo "deploy_path=${DEPLOY_PATH}" >> $GITHUB_OUTPUT

    - name: Deploy via FTP
      if: steps.load_deploy_config.outputs.deploy_type == 'ftp'
      run: |
        # Install lftp for advanced FTP mirroring with delete support
        sudo apt-get update && sudo apt-get install -y lftp
        
        # Set variables from repository secrets and deployment config
        TARGET_BRANCH="${{ needs.pre-check.outputs.target_branch }}"
        if [ "$TARGET_BRANCH" = "live" ]; then
          FTP_SERVER="${{ secrets.DEPLOY_HOST_LIVE }}"
          FTP_PORT="${{ secrets.DEPLOY_PORT_LIVE }}"
          FTP_USER="${{ secrets.DEPLOY_USERNAME_LIVE }}"
          FTP_PASSWORD="${{ secrets.DEPLOY_FTP_PASSWORD }}"
        else
          FTP_SERVER="${{ secrets.DEPLOY_HOST_STAGING }}"
          FTP_PORT="${{ secrets.DEPLOY_PORT_STAGING }}"
          FTP_USER="${{ secrets.DEPLOY_USERNAME_STAGING }}"
          FTP_PASSWORD="${{ secrets.DEPLOY_FTP_PASSWORD }}"
        fi
        LOCAL_DIR="_build_staging/"
        REMOTE_DIR="${{ steps.load_deploy_config.outputs.deploy_path }}"
        
        # Use lftp to mirror with delete (removes orphaned files after sync)
        lftp -c "
          set ssl:verify-certificate yes;
          set ftp:sync-mode false;
          open -u '$FTP_USER','$FTP_PASSWORD' -p '$FTP_PORT' '$FTP_SERVER';
          mirror -Rv --delete --exclude-glob '.git*' --exclude-glob 'node_modules' '$LOCAL_DIR' '$REMOTE_DIR';
          quit
        "

    - name: Deploy via SSH/SFTP
      if: steps.load_deploy_config.outputs.deploy_type == 'ssh'
      uses: burnett01/rsync-deployments@6.0.0
      with:
        switches: -avzr --delete
        path: _build_staging/
        remote_path: ${{ steps.load_deploy_config.outputs.deploy_path }}
        remote_host: ${{ needs.pre-check.outputs.target_branch == 'live' && secrets.DEPLOY_HOST_LIVE || secrets.DEPLOY_HOST_STAGING }}
        remote_port: ${{ needs.pre-check.outputs.target_branch == 'live' && secrets.DEPLOY_PORT_LIVE || secrets.DEPLOY_PORT_STAGING }}
        remote_user: ${{ needs.pre-check.outputs.target_branch == 'live' && secrets.DEPLOY_USERNAME_LIVE || secrets.DEPLOY_USERNAME_STAGING }}
        remote_key: ${{ secrets.DEPLOY_SSH_PRIVATE_KEY }}

    - name: Deployment Summary
      run: |
        TARGET_BRANCH="${{ needs.pre-check.outputs.target_branch }}"
        if [ "$TARGET_BRANCH" = "live" ]; then
          DEPLOY_HOST="${{ secrets.DEPLOY_HOST_LIVE }}"
          DEPLOY_USER="${{ secrets.DEPLOY_USERNAME_LIVE }}"
        else
          DEPLOY_HOST="${{ secrets.DEPLOY_HOST_STAGING }}"
          DEPLOY_USER="${{ secrets.DEPLOY_USERNAME_STAGING }}"
        fi
        
        echo "‚úÖ Successfully deployed via ${{ steps.load_deploy_config.outputs.deploy_type }}"
        echo "üåê Host: ${DEPLOY_HOST}"
        echo "üë§ User: ${DEPLOY_USER}"
        echo "üìÅ Source branch: ${{ github.ref_name }}"
        echo "üìÇ Deployed directories: ${{ needs.pre-check.outputs.build_dirs }}"
        echo "üîß Build configs used: ${{ needs.pre-check.outputs.build_configs }}"
        echo "üîó Called from: ${{ github.repository }}"
